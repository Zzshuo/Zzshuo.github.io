<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Protocol Buffer 编码</title>
    <link href="/2021/03/08/protocol-buffer-encoding/"/>
    <url>/2021/03/08/protocol-buffer-encoding/</url>
    
    <content type="html"><![CDATA[<p>本文描述了协议缓冲区消息的二进制总线格式。要在应用程序中使用协议缓冲区，您不需要了解这一点，但是了解不同的协议缓冲区格式如何影响编码消息的大小是非常有用的。</p><h2 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h2><p>Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p><p>除了最后一个字节外，varint编码中的每个字节都设置了最高有效位（most significant bit - msb）–msb为1则表明后面的字节还是属于当前数据的,如果是0那么这是当前数据的最后一个字节数据。每个字节的低7位用于以7位为一组存储数字的二进制补码表示，最低有效组在前，或者叫最低有效字节在前。这表明varint编码后数据的字节是按照小端序排列的。</p><p>大端序是按照数字的书写顺序进行存储的，而小端序是颠倒书写顺序进行存储的。</p><h3 id="原码求补码"><a href="#原码求补码" class="headerlink" title="原码求补码"></a>原码求补码</h3><ul><li><p>正数：补码与原码相同</p></li><li><p>负数：原码除符号位外取反（0变1，1变0，符号位为1不变）加1 。</p></li><li><p>0：补码0</p></li></ul><h3 id="补码求原码"><a href="#补码求原码" class="headerlink" title="补码求原码"></a>补码求原码</h3><ul><li><p>如果补码的符号位为“0”，表示是一个正数，其原码就是补码。</p></li><li><p>如果补码的符号位为“1”，表示是一个负数，补码的补码就是原码。</p></li><li><p>0：原码0</p></li></ul><h3 id="varint编码"><a href="#varint编码" class="headerlink" title="varint编码"></a>varint编码</h3><p>123456用二进制表示为<code>1 11100010 01000000</code>，每次低从向高取7位再加上最高有效位变成<code>1100 0000</code> <code>11000100</code> <code>00000111</code> 所以经过varint编码后123456占用三个字节分别为<code>192 196 7</code>。</p><h3 id="varint解码"><a href="#varint解码" class="headerlink" title="varint解码"></a>varint解码</h3><p>的过程就是将字节依次取出，去掉最高有效位，因为是小端排序所以先解码的字节要放在低位，之后解码出来的二进制位继续放在之前已经解码出来的二进制的高位最后转换为10进制数完成varint编码的解码过程。</p><p>如果用不到 1 个字节，那么最高有效位设为 0 ，如下面这个例子，1 用一个字节就可以表示，所以 msb 为 0.</p><pre><code class="hljs shell">0000 0001</code></pre><p>如果需要多个字节表示，msb 就应该设置为 1 。例如 300，如果用 Varint 表示的话：</p><pre><code class="hljs shell"> 1010 1100 0000 0010→ 010 1100  000 0010翻转→  000 0010 ++ 010 1100→  100101100→  256 + 32 + 8 + 4 = 300</code></pre><p><img src="https://gitee.com/Zzshuo/picture-bed/raw/master/img/bVbybpa.jpeg" alt="图片描述"></p><h3 id="Java编码实现"><a href="#Java编码实现" class="headerlink" title="Java编码实现"></a>Java编码实现</h3><pre><code class="hljs java">com.google.protobuf.CodedOutputStream  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeRawVarint32</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <span class="hljs-keyword">while</span>((value &amp; -<span class="hljs-number">128</span>) != <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">// 取出的value的后7个bit位前加上1（msb）</span>    <span class="hljs-keyword">this</span>.writeRawByte(value &amp; <span class="hljs-number">127</span> | <span class="hljs-number">128</span>);    <span class="hljs-comment">// 右移7位, 继续后面的数据处理</span>    value &gt;&gt;&gt;= <span class="hljs-number">7</span>;  &#125;  <span class="hljs-keyword">this</span>.writeRawByte(value);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">computeRawVarint32Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;  <span class="hljs-keyword">if</span> ((value &amp; -<span class="hljs-number">128</span>) == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value &amp; -<span class="hljs-number">16384</span>) == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((value &amp; -<span class="hljs-number">2097152</span>) == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> (value &amp; -<span class="hljs-number">268435456</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">4</span> : <span class="hljs-number">5</span>;  &#125;&#125;</code></pre><h3 id="Java解码实现"><a href="#Java解码实现" class="headerlink" title="Java解码实现"></a>Java解码实现</h3><pre><code class="hljs java">com.google.protobuf.CodedOutputStream<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readRawVarint32</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <span class="hljs-keyword">int</span> pos;  <span class="hljs-keyword">int</span> x;  label47: &#123;    pos = <span class="hljs-keyword">this</span>.bufferPos;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bufferSize != pos) &#123;      <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">this</span>.buffer;      <span class="hljs-keyword">byte</span> x;      <span class="hljs-keyword">if</span> ((x = buffer[pos++]) &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">this</span>.bufferPos = pos;        <span class="hljs-keyword">return</span> x;      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bufferSize - pos &gt;= <span class="hljs-number">9</span>) &#123;        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)(x = x ^ buffer[pos++] &lt;&lt; <span class="hljs-number">7</span>) &lt; <span class="hljs-number">0L</span>) &#123;          x = (<span class="hljs-keyword">int</span>)((<span class="hljs-keyword">long</span>)x ^ -<span class="hljs-number">128L</span>);          <span class="hljs-keyword">break</span> label47;        &#125;        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)(x ^= buffer[pos++] &lt;&lt; <span class="hljs-number">14</span>) &gt;= <span class="hljs-number">0L</span>) &#123;          x = (<span class="hljs-keyword">int</span>)((<span class="hljs-keyword">long</span>)x ^ <span class="hljs-number">16256L</span>);          <span class="hljs-keyword">break</span> label47;        &#125;        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>)(x ^= buffer[pos++] &lt;&lt; <span class="hljs-number">21</span>) &lt; <span class="hljs-number">0L</span>) &#123;          x = (<span class="hljs-keyword">int</span>)((<span class="hljs-keyword">long</span>)x ^ -<span class="hljs-number">2080896L</span>);          <span class="hljs-keyword">break</span> label47;        &#125;        <span class="hljs-keyword">int</span> y = buffer[pos++];        x ^= y &lt;&lt; <span class="hljs-number">28</span>;        x = (<span class="hljs-keyword">int</span>)((<span class="hljs-keyword">long</span>)x ^ <span class="hljs-number">266354560L</span>);        <span class="hljs-keyword">if</span> (y &gt;= <span class="hljs-number">0</span> || buffer[pos++] &gt;= <span class="hljs-number">0</span> || buffer[pos++] &gt;= <span class="hljs-number">0</span> || buffer[pos++] &gt;= <span class="hljs-number">0</span> || buffer[pos++] &gt;= <span class="hljs-number">0</span> || buffer[pos++] &gt;= <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">break</span> label47;        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)<span class="hljs-keyword">this</span>.readRawVarint64SlowPath();  &#125;  <span class="hljs-keyword">this</span>.bufferPos = pos;  <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">readRawVarint64SlowPath</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;  <span class="hljs-keyword">long</span> result = <span class="hljs-number">0L</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> shift = <span class="hljs-number">0</span>; shift &lt; <span class="hljs-number">64</span>; shift += <span class="hljs-number">7</span>) &#123;    <span class="hljs-keyword">byte</span> b = <span class="hljs-keyword">this</span>.readRawByte();    result |= (<span class="hljs-keyword">long</span>)(b &amp; <span class="hljs-number">127</span>) &lt;&lt; shift;    <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">return</span> result;    &#125;  &#125;  <span class="hljs-keyword">throw</span> InvalidProtocolBufferException.malformedVarint();&#125;</code></pre><h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><p>protocol buffer 中 message 是一系列键值对。使用字段号(field number + wire_type)作为 key。每个字段的名称和声明类型只能在解码端通过 <code>.proto</code> 文件来确定。这也是protocol buffer 比 JSON，XML 安全的原因，如果没有数据结构描述 <code>.proto</code> 文件，拿到数据以后是无法解释成正常的数据的。</p><p><img src="https://gitee.com/Zzshuo/picture-bed/raw/master/img/68747470733a2f2f696d672e68616c66726f73742e636f6d2f426c6f672f41727469636c65496d6167652f38345f372e706e67.png" alt="img"></p><p>采用了 tag-value 的形式，field 如果不为默认值，就存在在这个 message buffer 中，如果为默认值，就不会在这里，这一点也算是压缩了 message 的大小。</p><p>当消息编码时，键和值被连接成一个字节流。当消息被解码时，解析器需要能够跳过它无法识别的字段。这样，可以将新字段添加到消息中，而不会破坏不知道它们的旧程序。这就是所谓的 “向后”兼容性。</p><p>wire_type:</p><table><thead><tr><th align="left">Type</th><th align="left">Meaning</th><th align="left">Used For</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">Varint</td><td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td align="left">1</td><td align="left">64-bit</td><td align="left">fixed64, sfixed64, double</td></tr><tr><td align="left">2</td><td align="left">Length-delimited</td><td align="left">string, bytes, embedded messages, packed repeated fields</td></tr><tr><td align="left">3</td><td align="left">Start group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">4</td><td align="left">End group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">5</td><td align="left">32-bit</td><td align="left">fixed32, sfixed32, float</td></tr></tbody></table><p><strong>注意上图中，3 和 4 已经被废弃了，所以 wire_type 取值目前只有 0、1、2、5</strong>。</p><p>key 的计算方法是 <code>(field_number &lt;&lt; 3) | wire_type</code>，key 的最后 3 位表示 <code>wire_type</code>。</p><p>举例，一般 message 的字段号都是 1 开始的，所以对应的 tag 可能是这样的：</p><pre><code class="hljs basic"><span class="hljs-symbol">000 </span><span class="hljs-number">1000</span></code></pre><p>末尾 3 位表示的是 value 的类型，这里是 000，即 0 ，代表的是 varint 值。右移 3 位，即 0001，这代表的就是字段号(field number)。</p><p>接下来举一个 value 的例子，还是用 varint 来举例：</p><pre><code class="hljs angelscript"><span class="hljs-number">96</span> <span class="hljs-number">01</span> = <span class="hljs-number">1001</span> <span class="hljs-number">0110</span>  <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>       → <span class="hljs-number">000</span> <span class="hljs-number">0001</span>  ++  <span class="hljs-number">001</span> <span class="hljs-number">0110</span> (drop the msb <span class="hljs-keyword">and</span> reverse the groups of <span class="hljs-number">7</span> bits)       → <span class="hljs-number">10010110</span>       → <span class="hljs-number">128</span> + <span class="hljs-number">16</span> + <span class="hljs-number">4</span> + <span class="hljs-number">2</span> = <span class="hljs-number">150</span></code></pre><p>可以 96 01 代表的数据就是 150 。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test1</span> </span>&#123;  <span class="hljs-keyword">required</span> <span class="hljs-built_in">int32</span> a = <span class="hljs-number">1</span>;&#125;</code></pre><p>如果存在上面这样的一个 message 的结构，如果存入 150，在 Protocol Buffer 中显示的二进制应该为<code> 08 96 01</code> 。</p><p>额外说一句，type 需要注意的是 type = 2 的情况，tag 里面除了包含 field number 和 wire_type ，还需要再包含一个 length，决定 value 从那一段取出来。</p><h2 id="Signed-Integers-编码"><a href="#Signed-Integers-编码" class="headerlink" title="Signed Integers 编码"></a>Signed Integers 编码</h2><p>从上面的表格里面可以看到 wire_type = 0 中包含了无符号的 varints，但是如果是一个有符号数呢？</p><p>一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 10 个 byte 长度。</p><blockquote><p>为何 32 位和 64 位的负数都需要 10 个 byte 长度呢？</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CodedOutputStream::WriteVarint32SignExtended</span><span class="hljs-params">(int32 value)</span> </span>&#123; WriteVarint64(<span class="hljs-keyword">static_cast</span>&lt;uint64&gt;(value));&#125;</code></pre><p>因为源码里面是这么规定的。32 位的有符号数都会转换成 64 位无符号来处理。至于源码为什么要这么规定呢，猜想可能是怕 32 位的负数转换会有溢出的可能。(只是猜想)</p></blockquote><p>为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。<strong>将所有整数映射成无符号整数，然后再采用 varint 编码方式编码</strong>，这样，绝对值小的整数，编码后也会有一个较小的 varint 编码值。</p><p>Zigzag 映射函数为：</p><pre><code class="hljs excel">Zigzag(<span class="hljs-built_in">n</span>) = (<span class="hljs-built_in">n</span> &lt;&lt; <span class="hljs-number">1</span>) ^ (<span class="hljs-built_in">n</span> &gt;&gt; <span class="hljs-number">31</span>), <span class="hljs-built_in">n</span> 为 sint32 时Zigzag(<span class="hljs-built_in">n</span>) = (<span class="hljs-built_in">n</span> &lt;&lt; <span class="hljs-number">1</span>) ^ (<span class="hljs-built_in">n</span> &gt;&gt; <span class="hljs-number">63</span>), <span class="hljs-built_in">n</span> 为 sint64 时</code></pre><p>按照这种方法，-1 将会被编码成 1，1 将会被编码成 2，-2 会被编码成 3，如下表所示：</p><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/images/pb_zigzag.png"><img src="https://gitee.com/Zzshuo/picture-bed/raw/master/img/pb_zigzag.png" alt="img"></a></p><p>需要注意的是，第二个转换 <code>（n &gt;&gt; 31）</code> 部分，是一个算术转换。所以，换句话说，移位的结果要么是一个全为0（如果n是正数），要么是全部1（如果n是负数）。</p><p>当 sint32 或 sint64 被解析时，它的值被解码回原始的带符号的版本。</p><h2 id="Non-varint-Numbers"><a href="#Non-varint-Numbers" class="headerlink" title="Non-varint Numbers"></a>Non-varint Numbers</h2><p>Non-varint 数字比较简单，double 、fixed64 的 wire_type 为 1，在解析时告诉解析器，该类型的数据需要一个 64 位大小的数据块即可。同理，float 和 fixed32 的 wire_type 为5，给其 32 位数据块即可。两种情况下，都是高位在后，低位在前。</p><p><strong>说 Protocol Buffer 压缩数据没有到极限，原因就在这里，因为并没有压缩 float、double 这些浮点类型</strong>。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/images/protobuf_example.png"><img src="https://gitee.com/Zzshuo/picture-bed/raw/master/img/protobuf_example.png" alt="img"></a></p><p>wire_type 类型为 2 的数据，是一种指定长度的编码方式：key + length + content，key 的编码方式是统一的，length 采用 varints 编码方式，content 就是由 length 指定长度的 Bytes。</p><p>举例，假设定义如下的 message 格式：</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test2</span> </span>&#123;  <span class="hljs-keyword">optional</span> <span class="hljs-built_in">string</span> b = <span class="hljs-number">2</span>;&#125;</code></pre><p>设置该值为”testing”，二进制格式查看：</p><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">07</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">69</span> <span class="hljs-number">6e</span> <span class="hljs-number">67</span></code></pre><p>74 65 73 74 69 6e 67 是“testing”的 UTF8 代码。</p><p>此处，key 是16进制表示的，所以展开是：</p><p>12 -&gt; 0001 0010，后三位 010 为 wire type = 2，0001 0010 右移三位为 0000 0010，即 tag = 2。</p><p>length 此处为 7，后边跟着 7 个bytes，即我们的字符串”testing”。</p><p><strong>所以 wire_type 类型为 2 的数据，编码的时候会默认转换为 T-L-V (Tag - Length - Value)的形式</strong>。</p><h2 id="嵌入式-message"><a href="#嵌入式-message" class="headerlink" title="嵌入式 message"></a>嵌入式 message</h2><p>假设，定义如下嵌套消息：</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test3</span> </span>&#123;  <span class="hljs-keyword">optional</span> Test1 c = <span class="hljs-number">3</span>;&#125;</code></pre><p>设置字段为整数150，编码后的字节为：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>a <span class="hljs-number">03</span> <span class="hljs-number">08</span> <span class="hljs-number">96</span> <span class="hljs-number">01</span></code></pre><p>08 96 01 这三个代表的是 150，上面讲解过，这里就不再赘述了。</p><p>1a -&gt; 0001 1010，后三位 010 为 wire type = 2，0001 1010 右移三位为 0000 0011，即 tag = 3。</p><p>length 为 3，代表后面有 3 个字节，即 08 96 01 。</p><p>需要转变为 T - L - V 形式的还有 string, bytes, embedded messages, packed repeated fields （即 wire_type 为 2 的形式都会转变成 T - L - V 形式）</p><h2 id="Optional-和-Repeated-的编码"><a href="#Optional-和-Repeated-的编码" class="headerlink" title="Optional 和 Repeated 的编码"></a>Optional 和 Repeated 的编码</h2><p>在 proto2 中定义成 repeated 的字段，（没有加上 [packed=true] option ），编码后的 message 有一个或者多个包含相同 tag 数字的 key-value 对。这些重复的 value 不需要连续的出现；他们可能与其他的字段间隔的出现。尽管他们是无序的，但是在解析时，他们是需要有序的。在 proto3 中 repeated 字段默认采用 packed 编码</p><p>对于 proto3 中的任何非重复字段或 proto2 中的可选字段，编码的 message 可能有也可能没有包含该字段号的键值对。</p><p>通常，编码后的 message，其 required 字段和 optional 字段最多只有一个实例。但是解析器却需要处理多对一的情况。对于数字类型和 string 类型，如果同一值出现多次，解析器接受最后一个它收到的值。对于内嵌字段，解析器合并(merge)它接收到的同一字段的多个实例。就如 MergeFrom 方法一样，所有单数的字段，后来的会替换先前的，所有单数的内嵌 message 都会被合并(merge)，所有的 repeated 字段，都会串联起来。这样的规则的结果是，<strong>解析两个串联的编码后的 message，与分别解析两个 message 然后 merge，结果是一样的</strong>。例如：</p><pre><code class="hljs reasonml">MyMessage message;message.<span class="hljs-constructor">ParseFromString(<span class="hljs-params">str1</span> + <span class="hljs-params">str2</span>)</span>;</code></pre><p>等价于</p><pre><code class="hljs reasonml">MyMessage message, message2;message.<span class="hljs-constructor">ParseFromString(<span class="hljs-params">str1</span>)</span>;message2.<span class="hljs-constructor">ParseFromString(<span class="hljs-params">str2</span>)</span>;message.<span class="hljs-constructor">MergeFrom(<span class="hljs-params">message2</span>)</span>;</code></pre><p>这种方法有时是非常有用的。比如，即使不知道 message 的类型，也能够将其合并。</p><h2 id="Packed-Repeated-Fields"><a href="#Packed-Repeated-Fields" class="headerlink" title="Packed Repeated Fields"></a>Packed Repeated Fields</h2><p>在 2.1.0 版本以后，protocol buffers 引入了该种类型，其与 repeated 字段一样，只是在末尾声明了 [packed=true]。类似 repeated 字段却又不同。在 proto3 中 Repeated 字段默认就是以这种方式处理。对于 packed repeated 字段，如果 message 中没有赋值，则不会出现在编码后的数据中。否则的话，该字段所有的元素会被打包到单一一个 key-value 对中，且它的 wire_type=2，长度确定。每个元素正常编码，只不过其前没有标签 tag。例如有如下 message 类型：</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test4</span> </span>&#123;  <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">int32</span> d = <span class="hljs-number">4</span> [packed=<span class="hljs-literal">true</span>];&#125;</code></pre><p>构造一个 Test4 字段，并且设置 repeated 字段 d 3个值：3，270和86942，编码后：</p><pre><code class="hljs yaml"><span class="hljs-number">22</span> <span class="hljs-string">//</span> <span class="hljs-string">tag</span> <span class="hljs-number">0010 </span><span class="hljs-number">0010</span><span class="hljs-string">(field</span> <span class="hljs-string">number</span> <span class="hljs-number">010</span> <span class="hljs-number">0</span> <span class="hljs-string">=</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-string">wire</span> <span class="hljs-string">type</span> <span class="hljs-number">010</span> <span class="hljs-string">=</span> <span class="hljs-number">2</span><span class="hljs-string">)</span><span class="hljs-number">06</span> <span class="hljs-string">//</span> <span class="hljs-string">payload</span> <span class="hljs-string">size</span> <span class="hljs-string">(设置的length</span> <span class="hljs-string">=</span> <span class="hljs-number">6</span> <span class="hljs-string">bytes)</span> <span class="hljs-number">03</span> <span class="hljs-string">//</span> <span class="hljs-string">first</span> <span class="hljs-string">element</span> <span class="hljs-string">(varint</span> <span class="hljs-number">3</span><span class="hljs-string">)</span> <span class="hljs-string">8E</span> <span class="hljs-number">02</span> <span class="hljs-string">//</span> <span class="hljs-string">second</span> <span class="hljs-string">element</span> <span class="hljs-string">(varint</span> <span class="hljs-number">270</span><span class="hljs-string">)</span> <span class="hljs-string">9E</span> <span class="hljs-string">A7</span> <span class="hljs-number">05</span> <span class="hljs-string">//</span> <span class="hljs-string">third</span> <span class="hljs-string">element</span> <span class="hljs-string">(varint</span> <span class="hljs-number">86942</span><span class="hljs-string">)</span></code></pre><p><strong>形成了 Tag - Length - Value - Value - Value …… 对</strong>。</p><p>只有原始数字类型（使用varint，32位或64位）的重复字段才可以声明为“packed”。</p><p>有一点需要注意，对于 packed 的 repeated 字段，尽管通常没有理由将其编码为多个 key-value 对，编码器必须有接收多个 key-pair 对的准备。这种情况下，payload 必须是串联的，每个 pair 必须包含完整的元素。</p><p>Protocol Buffer 解析器必须能够解析被重新编译为 packed 的字段，就像它们未被 packed 一样，反之亦然。这允许以正向和反向兼容的方式将[packed = true]添加到现有字段。</p><h2 id="Field-Order"><a href="#Field-Order" class="headerlink" title="Field Order"></a>Field Order</h2><p>编码/解码与字段顺序无关，这一点由 key-value 机制保证。</p><p>如果消息具有未知字段，则当前的 Java 和 C++ 实现在按顺序排序的已知字段之后以任意顺序写入它们。</p><h2 id="protocol-buffers-的优缺点"><a href="#protocol-buffers-的优缺点" class="headerlink" title="protocol buffers 的优缺点"></a>protocol buffers 的优缺点</h2><p>protocol buffers 在序列化方面，与 XML 相比，有诸多优点：</p><ul><li>更加简单</li><li>数据体积小 3- 10 倍</li><li>更快的反序列化速度，提高 20 - 100 倍</li><li>可以自动化生成更易于编码方式使用的数据访问类</li></ul><p>举个例子：</p><p>如果要编码一个用户的名字和 email 信息，用 XML 的方式如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">person</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zheng<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>zheng@example.com<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">person</span>&gt;</span></code></pre><p>相同需求，如果换成 protocol buffers 来实现，定义文件如下：</p><pre><code class="hljs applescript"><span class="hljs-comment"># Textual representation of a protocol buffer.</span><span class="hljs-comment"># This is *not* the binary format used on the wire.</span>person &#123;  <span class="hljs-built_in">name</span>: <span class="hljs-string">&quot;zheng&quot;</span>  email: <span class="hljs-string">&quot;zheng@example.com&quot;</span>&#125;</code></pre><p>protocol buffers 通过编码以后，以二进制的方式进行数据传输，最多只需要 28 bytes 空间和 100-200 ns 的反序列化时间。但是 XML 则至少需要 69 bytes 空间（经过压缩以后，去掉所有空格）和 5000-10000 的反序列化时间。</p><p>Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。</p><p>使用 Protobuf 无需学习复杂的文档对象模型，Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。</p><p>protocol buffers 最后一个非常棒的特性是，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变(因为存储方式本来就是无序的，k-v 形式)。</p><p>当然 protocol buffers 也并不是完美的，在使用上存在一些局限性。</p><p>由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 <code>.proto</code> 定义，否则你没法直接读出 Protobuf 的任何内容。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>读完本篇 Protocol Buffer 编码原理以后，读者应该能明白以下几点：</p><ol><li>Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。所以 pb 体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。</li><li>Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！</li><li>Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。</li><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md">https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/Protocol-buffers-encode.md</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding">https://developers.google.com/protocol-buffers/docs/encoding</a></p>]]></content>
    
    
    <categories>
      
      <category>protobuf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Protocol Buffers Guide（Proto3）</title>
    <link href="/2021/03/07/protocol-buffer-guide/"/>
    <url>/2021/03/07/protocol-buffer-guide/</url>
    
    <content type="html"><![CDATA[<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">官方文档</a></p><p>2001年初，Protobuf首先在Google内部创建， 我们把它称之为 <code>proto1</code>，一直以来在Google的内部使用，其中也不断的演化，根据使用者的需求也添加很多新的功能，一些内部库依赖它。几乎每个Google的开发者都会使用到它。</p><p>Google开始开源它的内部项目时，因为依赖的关系，所以他们决定首先把Protobuf开源出去。 proto1在演化的过程中有些混乱，所以Protobuf的开发者重写了Protobuf的实现，保留了proto1的大部分设计，以及proto1的很多的想法。但是开源的proto2不依赖任何的Google的库，代码也相当的清晰。2008年7月7日，Protobuf开始公布出来。</p><p>Protobuf公布出来也得到了大家的广泛的关注， 逐步地也得到了大家的认可，很多项目也采用Protobuf进行消息的通讯，还有基于Protobuf的微服务框架GRPC。在使用的过程中，大家也提出了很多的意见和建议，Protobuf也在演化，于2016年推出了Proto3。 Proto3简化了proto2的开发，提高了开发的效能，但是也带来了版本不兼容的问题。</p><p>目前Protobuf的稳定版本是3.9.2，于2019年9月23日发布。由于很多公司很早的就采用了Protobuf，所以很多项目还在使用proto2协议，目前是proto2和proto3同时在使用的状态。</p><p>Protocol Buffer名称来自于初期一个主要的类的名称<code>ProtocolBuffer</code>。</p><p>Google当前并没有Protobuf的相关专利，所以不必担心侵权的问题。</p><h2 id="What-are-protocol-buffers"><a href="#What-are-protocol-buffers" class="headerlink" title="What are protocol buffers?"></a>What are protocol buffers?</h2><p>Protocol buffers 是一种语言无关，平台无关，可扩展的序列化数据的格式。</p><blockquote><p>Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.</p></blockquote><p><strong>protocol buffers 诞生之初是为了解决服务器端新旧协议(高低版本)兼容性问题，名字也很体贴，“协议缓冲区”。只不过后期慢慢发展成用于传输数据</strong>。</p><h2 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h2><p>Java、Python、Objective-c、C++、C#、Go、Ruby、Dart、with more.</p><h2 id="proto3-新特性"><a href="#proto3-新特性" class="headerlink" title="proto3 新特性"></a>proto3 新特性</h2><ul><li>移除了原始值字段的出现逻辑。</li><li>移除了<code>required</code>字段</li><li>移除了缺省值</li><li>移除了<code>unknown</code>字段 （3.5中又加上了）</li><li>移除了扩展，使用<code>Any</code>代替</li><li>修复了未知的枚举值的语义</li><li>添加了map类型</li><li>添加了一些标准类似，比如time、动态数据的呈现</li><li>可以使用JSON编码代替二进制proto编码</li></ul><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><p>使用<code>.proto</code>文件来定义消息类型</p><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchRequest</span> </span>&#123;  <span class="hljs-built_in">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-built_in">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-built_in">int32</span> result_per_page = <span class="hljs-number">3</span>;&#125;</code></pre><ul><li>第一行是声明了使用<code>proto3</code>语法解析，必须在第一个非空、非注释行。如果不声明，则默认使用<code>proto2</code>语法解析</li><li><code>SearchRequest</code>定义了3个字段，每个字段都有包含了名称、类型、编号</li></ul><h3 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h3><p>消息定义中的每个字段都有一个唯一编号。这些编号用于在消息二进制格式中标识字段，并且在消息类型被使用后不应该被更改。</p><p>1 - 15 字段编号需要一个字节进行编码，包括字段编号和字段类型（具体原因见<a href="https://developers.google.com/protocol-buffers/docs/encoding#structure">Protocol Buffer Encoding</a> structure章节），16 - 2047 字段编号需要两个字节。所以应该保留数字 1 到 15 作为常用的消息元素。请记住可以为将来可能频繁出现的元素预留一些空间。</p><p>字段编号为1-2^29^-1 或 536,870,911，19000-19999（FieldDescriptor :: kFirstReservedNumber 到 FieldDescriptor :: kLastReservedNumber）为保留字段不能使用，编译时会报错。</p><h3 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h3><p>字段规则遵循以下之一</p><ul><li>singular:一个格式良好的消息可以有0个或其中一个字段(但不能超过一个)(proto3默认字段规则)</li><li>repeated:可以重复多次，但是重复值的顺序会被保留（数组）</li></ul><p>在 proto3 中，纯数字类型的 repeated 字段编码时候默认采用 packed 编码（具体原因见<a href="https://developers.google.com/protocol-buffers/docs/encoding#packed">Protocol Buffer Encoding</a> packed章节）</p><h3 id="多消息类型"><a href="#多消息类型" class="headerlink" title="多消息类型"></a>多消息类型</h3><p>多个消息类型可以定义在一个<code>.proto</code>文件里，如下所示，一个SearchRequest，一个SearchResponse。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchRequest</span> </span>&#123;  <span class="hljs-built_in">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-built_in">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-built_in">int32</span> result_per_page = <span class="hljs-number">3</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchResponse</span> </span>&#123; ...&#125;</code></pre><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>使用 <code>//</code> 或者 <code>/* ... */</code> 语法添加备注</p><pre><code class="hljs protobuf"><span class="hljs-comment">/* SearchRequest represents a search query, with pagination options to</span><span class="hljs-comment"> * indicate which results to include in the response. */</span><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchRequest</span> </span>&#123;  <span class="hljs-built_in">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-built_in">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-comment">// Which page number do we want?</span>  <span class="hljs-built_in">int32</span> result_per_page = <span class="hljs-number">3</span>;  <span class="hljs-comment">// Number of results to return per page.</span>&#125;</code></pre><h3 id="reserved"><a href="#reserved" class="headerlink" title="reserved"></a><code>reserved</code></h3><p>保留字段、用来指明此message不使用某些字段，也就是忽略这些字段。</p><p>如果删除或注释掉某个字段来更新消息类型，用户可能会在后面重新使用这个字段，如果加载到了旧版<code>.proto</code>文件，会导致出现数据混乱、序列化等问题。确保不会发生这种问题，使用<code>reserved</code>标识这些字段，如果后面使用了这些字段，编译时会报错。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Foo</span> </span>&#123;  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>;  reserved <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>;&#125;</code></pre><blockquote><p>不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号，可以像上面这个例子这样分开写。</p></blockquote><h3 id="proto文件的生成"><a href="#proto文件的生成" class="headerlink" title=".proto文件的生成"></a><code>.proto</code>文件的生成</h3><p>编译器会根据你选择的的语言以及在<code>.proto</code>描述的消息类型生成对应的代码，包括get、set字段值，序列化消息到输出流，从输入流解析消息。</p><ul><li>Java：编译器生成一个.java文件，其中包含每个消息类型的类，以及用于创建消息类实例的特殊构建器类。</li><li>C++：编译器从每个.proto中生成.h和.cc文件，并为文件中描述的每种消息类型生成一个类。</li><li>…</li></ul><p>更多API详情参考 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API reference</a> </p><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><h3 id="标量-基本-标准类型-Scalar-Value-Types"><a href="#标量-基本-标准类型-Scalar-Value-Types" class="headerlink" title="标量/基本/标准类型(Scalar Value Types)"></a>标量/基本/标准类型(Scalar Value Types)</h3><ul><li>数字类型： double、float、int32、int64、uint32、uint64、sint32、sint64: 存储长度可变的浮点数、整数、无符号整数和有符号整数</li><li>存储固定大小的数字类型：fixed32、fixed64、sfixed32、sfixed64: 存储空间固定</li><li>布尔类型: bool</li><li>字符串: string</li><li>bytes: 字节数组</li><li>enum:枚举类型</li></ul><h3 id="message-消息类型"><a href="#message-消息类型" class="headerlink" title="message: 消息类型"></a>message: 消息类型</h3><p>可以用相同的.proto定义一个结果消息类型，然后在SearchResponse中指定一个Result类型的字段:</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchResponse</span> </span>&#123;  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Result</span> </span>&#123;  <span class="hljs-built_in">string</span> url = <span class="hljs-number">1</span>;  <span class="hljs-built_in">string</span> title = <span class="hljs-number">2</span>;  <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> snippets = <span class="hljs-number">3</span>;&#125;</code></pre><ul><li><p>你在 proto3 中可以引用 proto2 消息类型，反之亦可。</p></li><li><p>proto2 语法格式的枚举类型，不可以在 proto3 中引用。</p></li><li><p>可以通过导入其他.proto文件来使用它们的定义。<strong>注意，此特性在Java中不可用。</strong></p></li></ul><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;myproject/other_protos.proto&quot;</span>;</code></pre><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>字符串默认值为空字符串。</li><li>字节类型默认值是空字节。</li><li>布尔类型默认值为 false。</li><li>数值类型默认值位 0。</li><li>枚举 类型默认值是第一个枚举元素，它必须为 0。</li><li>消息类型字段默认值为 null。</li></ul><blockquote><p>对于标准数据类型的字段，当消息被解析的时候没有办法显示地设定默认值的。</p><p>序列化时，如果标准类型的字段的值等于它的默认值，这个值是不会存储到介质上的。</p></blockquote><h3 id="标量类型映射表"><a href="#标量类型映射表" class="headerlink" title="标量类型映射表"></a>标量类型映射表</h3><table><thead><tr><th align="left">.proto Type</th><th align="left">Notes</th><th align="left">C++ Type</th><th align="left">Java Type</th><th align="left">Python Type[2]</th><th align="left">Go Type</th><th align="left">C# Type</th></tr></thead><tbody><tr><td align="left">double</td><td align="left"></td><td align="left">double</td><td align="left">double</td><td align="left">float</td><td align="left">float64</td><td align="left">double</td></tr><tr><td align="left">float</td><td align="left"></td><td align="left">float</td><td align="left">float</td><td align="left">float</td><td align="left">float32</td><td align="left">float</td></tr><tr><td align="left">int32</td><td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">int</td></tr><tr><td align="left">int64</td><td align="left">Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long[3]</td><td align="left">int64</td><td align="left">long</td></tr><tr><td align="left">uint32</td><td align="left">Uses variable-length encoding.</td><td align="left">uint32</td><td align="left">int[1]</td><td align="left">int/long[3]</td><td align="left">uint32</td><td align="left">uint</td></tr><tr><td align="left">uint64</td><td align="left">Uses variable-length encoding.</td><td align="left">uint64</td><td align="left">long[1]</td><td align="left">int/long[3]</td><td align="left">uint64</td><td align="left">ulong</td></tr><tr><td align="left">sint32</td><td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">int</td></tr><tr><td align="left">sint64</td><td align="left">Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long[3]</td><td align="left">int64</td><td align="left">long</td></tr><tr><td align="left">fixed32</td><td align="left">Always four bytes. More efficient than uint32 if values are often greater than 228.</td><td align="left">uint32</td><td align="left">int[1]</td><td align="left">int/long[3]</td><td align="left">uint32</td><td align="left">uint</td></tr><tr><td align="left">fixed64</td><td align="left">Always eight bytes. More efficient than uint64 if values are often greater than 256.</td><td align="left">uint64</td><td align="left">long[1]</td><td align="left">int/long[3]</td><td align="left">uint64</td><td align="left">ulong</td></tr><tr><td align="left">sfixed32</td><td align="left">Always four bytes.</td><td align="left">int32</td><td align="left">int</td><td align="left">int</td><td align="left">int32</td><td align="left">int</td></tr><tr><td align="left">sfixed64</td><td align="left">Always eight bytes.</td><td align="left">int64</td><td align="left">long</td><td align="left">int/long[3]</td><td align="left">int64</td><td align="left">long</td></tr><tr><td align="left">bool</td><td align="left"></td><td align="left">bool</td><td align="left">boolean</td><td align="left">bool</td><td align="left">bool</td><td align="left">bool</td></tr><tr><td align="left">string</td><td align="left">A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</td><td align="left">string</td><td align="left">String</td><td align="left">str/unicode[4]</td><td align="left">string</td><td align="left">string</td></tr><tr><td align="left">bytes</td><td align="left">May contain any arbitrary sequence of bytes no longer than 232.</td><td align="left">string</td><td align="left">ByteString</td><td align="left">str</td><td align="left">[]byte</td><td align="left">ByteString</td></tr></tbody></table><ul><li>[1] 在 Java 中，无符号的 32 位和 64 位整数使用对应带符号的表示方法，最高位存储符号位。</li><li>[2] 在所有情况下，给一个字段设置一个值的时候都会执行类型检查以确保其有效。</li><li>[3] 64 位或无符号 32 位整数在解码时始终表示为 long，但是如果在设置字段的时候设置了 int，则可以为 int。 在所有情况下，该值都必须符合设置时表示的类型。参见[2]。</li><li>[4] Python 字符串在解码时表示为 unicode，但如果给出了 ASCII 字符串，则可以为 str（此字符串可能会发生变化）。</li><li>[5] 在 64 位计算机上使用 Integer，在 32 位计算机上使用 string。</li></ul><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchRequest</span> </span>&#123;  <span class="hljs-built_in">string</span> query = <span class="hljs-number">1</span>;  <span class="hljs-built_in">int32</span> page_number = <span class="hljs-number">2</span>;  <span class="hljs-built_in">int32</span> result_per_page = <span class="hljs-number">3</span>;  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Corpus</span> </span>&#123;    UNIVERSAL = <span class="hljs-number">0</span>;    WEB = <span class="hljs-number">1</span>;    IMAGES = <span class="hljs-number">2</span>;    LOCAL = <span class="hljs-number">3</span>;    NEWS = <span class="hljs-number">4</span>;    PRODUCTS = <span class="hljs-number">5</span>;    VIDEO = <span class="hljs-number">6</span>;  &#125;  Corpus corpus = <span class="hljs-number">4</span>;&#125;</code></pre><ul><li>第一个枚举值必须是0，而且必须定义。</li><li>枚举的常量必须是一个32比特的整数，从效率的角度考虑，不推荐采用负数。</li><li>可以在message中定义枚举，也可以在外部定义，类似于java枚举</li></ul><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以把相同的值分配给不同的枚举常量来定义别名，需要设置<code>allow_alias = true</code></p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MyMessage1</span> </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumAllowingAlias</span> </span>&#123;    <span class="hljs-keyword">option</span> allow_alias = <span class="hljs-literal">true</span>;    UNKNOWN = <span class="hljs-number">0</span>;    STARTED = <span class="hljs-number">1</span>;    RUNNING = <span class="hljs-number">1</span>;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MyMessage2</span> </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumNotAllowingAlias</span> </span>&#123;    UNKNOWN = <span class="hljs-number">0</span>;    STARTED = <span class="hljs-number">1</span>;    <span class="hljs-comment">// RUNNING = 1;  // 取消注释会导致编译错误，因为没有设置允许别名</span>  &#125;&#125;</code></pre><h3 id="枚举保留值"><a href="#枚举保留值" class="headerlink" title="枚举保留值"></a>枚举保留值</h3><p> <code>max</code> 指定保留数值范围上升到最大可能值。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Foo</span> </span>&#123;  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>, <span class="hljs-number">40</span> to max;  reserved <span class="hljs-string">&quot;FOO&quot;</span>, <span class="hljs-string">&quot;BAR&quot;</span>;&#125;</code></pre><blockquote><p>不能在同一个 <code>reserved</code> 语句中混合字段名称和字段编号，可以像上面这个例子这样分开写。</p></blockquote><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>Protocol Buffers 定义 message 允许嵌套组合成更加复杂的消息。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SearchResponse</span> </span>&#123;  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Result</span> </span>&#123;    <span class="hljs-built_in">string</span> url = <span class="hljs-number">1</span>;    <span class="hljs-built_in">string</span> title = <span class="hljs-number">2</span>;    <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> snippets = <span class="hljs-number">3</span>;  &#125;  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;&#125;</code></pre><p>引用其他message中的消息</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SomeOtherMessage</span> </span>&#123;  SearchResponse.Result result = <span class="hljs-number">1</span>;&#125;</code></pre><p>深度嵌套(你喜欢)</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Outer</span> </span>&#123;                  <span class="hljs-comment">// Level 0</span>  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MiddleAA</span> </span>&#123;  <span class="hljs-comment">// Level 1</span>    <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Inner</span> </span>&#123;   <span class="hljs-comment">// Level 2</span>      <span class="hljs-built_in">int64</span> ival = <span class="hljs-number">1</span>;      <span class="hljs-built_in">bool</span>  booly = <span class="hljs-number">2</span>;    &#125;  &#125;  <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MiddleBB</span> </span>&#123;  <span class="hljs-comment">// Level 1</span>    <span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Inner</span> </span>&#123;   <span class="hljs-comment">// Level 2</span>      <span class="hljs-built_in">int32</span> ival = <span class="hljs-number">1</span>;      <span class="hljs-built_in">bool</span>  booly = <span class="hljs-number">2</span>;    &#125;  &#125;&#125;</code></pre><h2 id="更新消息类型"><a href="#更新消息类型" class="headerlink" title="更新消息类型"></a>更新消息类型</h2><p>有时候你不得不修改正在使用的proto文件，比如为类型增加一个字段，protobuf支持这种修改而不影响已有的服务，不过你需要遵循一定的规则：</p><ol><li>不要改动原有字段的数据结构（名称、类型、编号）。</li><li>当增加一个新的字段的时候，老系统序列化后的数据依然可以被你的新的格式所解析，只不过你需要处理新加字段的缺省值。 老系统也能解析你信息的值，新加字段只不过被丢弃了</li><li>字段也可以被移除，但是建议你Reserved这个字段，避免将来会使用这个字段</li><li>int32，uint32，int64，uint64 和 bool 全都兼容。不匹配将被截断（例如，如果将 64 位数字读为 int32，它将被截断为 32 位）。</li><li>sint32 和 sint64 相互兼容，但与其他整数类型不兼容。</li><li>string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes。</li><li>嵌入式message和bytes兼容，如果bytes包含一个message编码版本。</li><li>fixed32与sfixed32兼容，fixed64与sfixed64兼容。</li><li>enum 就数组而言，是可以与 int32，uint32，int64 和 uint64 兼容（不匹配将被截断）。但是请注意，当消息反序列化时，客户端代码可能会以不同的方式对待它们：例如，未识别的 proto3 枚举类型将保留在消息中，但消息反序列化时如何表示是与语言相关的。Int 域始终只保留它们的值。</li><li>把单一一个值改变成一个新的oneof类型的一个成员是安全和二进制兼容的。把一组字段变成一个新的oneof字段也是安全的，如果你确保这一组字段最多只会设置一个。把一个字段移动到一个已存在的oneof字段是不安全的（注意字段和值的区别，字段是 field，值是 value）</li></ol><h2 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h2><p>未知类型是指数据的格式符合Protobuf的定义，但是数据中的某个/某些字段解析器无法识别的字段类型。一般发生在proto文件有变化，新旧数据不一致的情况导致。</p><p>proto3最开始对于不能识别的数据就丢弃掉了，但是自3.5 版本后重新引入了未知字段，以匹配proto2的行为。</p><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>Any消息类型允许您将消息作为嵌入类型使用，而不需要它们的.proto定义</p><pre><code class="hljs protobuf"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/any.proto&quot;</span>;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">ErrorStatus</span> </span>&#123;  <span class="hljs-built_in">string</span> <span class="hljs-class"><span class="hljs-keyword">message</span> = 1;</span><span class="hljs-class">  <span class="hljs-title">repeated</span> google.protobuf.Any details = 2;</span><span class="hljs-class">&#125;</span></code></pre><p><code>google.protobuf.Any</code> 可以理解为Java中的Object，但又和Object有所不同。Any不是所有的Message的父类，而Object是所有类的父类。</p><h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果你有一组字段，同时最多允许这一组中的一个字段出现，就可以使用<code>Oneof</code>定义这一组字段。</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">SampleMessage</span> </span>&#123;  <span class="hljs-keyword">oneof</span> test_oneof &#123;    <span class="hljs-built_in">string</span> name = <span class="hljs-number">4</span>;    SubMessage sub_message = <span class="hljs-number">9</span>;  &#125;&#125;</code></pre><p>因为proto3没有办法区分正常的值是否是设置了还是取得缺省值(比如int64类型字段，如果它的值是0，你无法判断数据是否包含这个字段，因为0几可能是数据中设置的值，也可能是这个字段的零值)，所以你可以通过Oneof取得这个功能，因为Oneof有判断字段是否设置的功能。</p><ul><li><p>设置 oneof 组中某一个成员的值时，其它成员的值被自动清除。因此，当你的 oneof 组中有多个成员的时候，只有最有一个被赋值的字段拥有自己的值。</p><pre><code class="hljs java">SampleMessage message;message.set_name(<span class="hljs-string">&quot;name&quot;</span>);CHECK(message.has_name());message.mutable_sub_message(); <span class="hljs-comment">// Will clear name field.</span>CHECK(!message.has_name());</code></pre></li><li><p>如果解析器发现多个 oneof 组的成员被存储在介质上，只有最后一个成员被解析到消息中。</p></li><li><p>oneof 字段不能是 repeated 可重复的（数组）。</p></li><li><p>oneof 字段可以使用反射函数。</p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code class="hljs cpp"><span class="hljs-built_in">map</span>&lt;key_type, value_type&gt; map_field = N;<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, Project&gt; projects = <span class="hljs-number">3</span>;</code></pre><ul><li><code>key_type</code> 可以是任何整形或者字符串类型(任何的标量类型，除了float、double 和 bytes)</li><li>枚举值也不能作为 key。</li><li><code>value_type</code> 可以是除去 map 以外的任何类型。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>map 不能用 repeated 修饰。</li><li>map 是无序的。</li><li>为 <code>.proto</code> 生成文本格式时，map 按 key 排序。数字的 key 按数字排序。</li><li>数组解析或合并成map时，如果有重复的 key，则使用所看到的最后一个 key（覆盖原则）。从文本格式解析映射时，如果有重复的 key，解析可能会失败。</li></ul><p>Protocol Buffer 虽然不支持 map 类型的数组，但是可以转换一下，用以下思路实现 maps 数组：</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">MapFieldEntry</span> </span>&#123;  key_type key = <span class="hljs-number">1</span>;  value_type value = <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">repeated</span> MapFieldEntry map_field = N;</code></pre><p>上述写法和 map 数组是完全等价的，所以用 repeated 巧妙的实现了 maps 数组的需求。</p><h2 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h2><p>定义proto的包名，包名可以避免对message 类型之间的名字冲突，同名的Message可以通过package进行区分。</p><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> foo.bar;<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Open</span> </span>&#123; ... &#125;</code></pre><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Foo</span> </span>&#123;  ...  foo.bar.Open open = <span class="hljs-number">1</span>;  ...&#125;</code></pre><p>在没有为特定语言定义<code>option xxx_package</code>的时候，它还可以用来生成特定语言的包名:</p><ul><li>在c++中，生成的类被包装在c++命名空间中。例如，Open应该在命名空间foo::bar中。</li><li>在Java中，包被用作Java包，除非您在.proto文件中显式地提供了一个java_package选项。</li><li>在Python中，package指令会被忽略，因为Python模块是根据它们在文件系统中的位置来组织的。</li></ul><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>如果想在 RPC（远程过程调用）系统中使用自定义的消息类型，你可以在.proto 文件中定义一个 RPC 服务，protocol buffer  编译器就会根据你选择的编程语言生成服务器接口和存根代码。例如，定义一个 RPC 服务，根据 <code>SearchRequest</code> 返回<code>SearchResponse</code>：</p><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">SearchService</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;&#125;</code></pre><p>与protocol buffer  一起使用的最直接的RPC系统是gRPC，它允许你使用一个特殊的协议缓冲区编译器插件，直接从你的.proto文件中生成相关的RPC代码。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="字段名"><a href="#字段名" class="headerlink" title="字段名"></a>字段名</h3><p>首字母必须是字母类型，然后可以是字母、数字或者下划线_。</p><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><p>采用驼峰命名法。message 首字母大写开头。字段名采用下划线分隔法命名。</p><pre><code class="hljs proto">message SongServerRequest &#123;  required string song_name &#x3D; 1;&#125;</code></pre><h3 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h3><p>采用驼峰命名法。枚举类型首字母大写开头。每个枚举值全部大写，并且采用下划线分隔法命名。</p><pre><code class="hljs proto">enum Foo &#123;  FIRST_VALUE &#x3D; 0;  SECOND_VALUE &#x3D; 1;&#125;</code></pre><p><strong>每个枚举值用分号结束，不是逗号</strong>。</p><h3 id="服务名和方法名"><a href="#服务名和方法名" class="headerlink" title="服务名和方法名"></a>服务名和方法名</h3><p>驼峰命名法，并且首字母都大写开头。</p><pre><code class="hljs proto">service FooService &#123;  rpc GetSomething(FooRequest) returns (FooResponse);&#125;</code></pre><h2 id="JSON-Mapping"><a href="#JSON-Mapping" class="headerlink" title="JSON Mapping"></a>JSON Mapping</h2><p>Proto3支持JSON格式的规范编码，使得在系统之间共享数据变得更加容易。</p><p>如果 JSON 编码数据中缺少值或其值为空，则在解析为 protocol buffer 时，它将被解释为适当的默认值。</p><p>如果一个字段在protocol buffer 中具有默认值，默认情况下它将在 JSON 编码数据中省略以节省空间</p><table><thead><tr><th align="left">proto3</th><th align="left">JSON</th><th align="left">JSON example</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">message</td><td align="left">object</td><td align="left"><code>&#123;&quot;fooBar&quot;: v, &quot;g&quot;: null, …&#125;</code></td><td align="left">Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the <code>json_name</code> field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the <code>json_name</code> option) and the original proto field name. <code>null</code> is an accepted value for all field types and treated as the default value of the corresponding field type.</td></tr><tr><td align="left">enum</td><td align="left">string</td><td align="left"><code>&quot;FOO_BAR&quot;</code></td><td align="left">The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values.</td></tr><tr><td align="left">map&lt;K,V&gt;</td><td align="left">object</td><td align="left"><code>&#123;&quot;k&quot;: v, …&#125;</code></td><td align="left">All keys are converted to strings.</td></tr><tr><td align="left">repeated V</td><td align="left">array</td><td align="left"><code>[v, …]</code></td><td align="left"><code>null</code> is accepted as the empty list <code>[]</code>.</td></tr><tr><td align="left">bool</td><td align="left">true, false</td><td align="left"><code>true, false</code></td><td align="left"></td></tr><tr><td align="left">string</td><td align="left">string</td><td align="left"><code>&quot;Hello World!&quot;</code></td><td align="left"></td></tr><tr><td align="left">bytes</td><td align="left">base64 string</td><td align="left"><code>&quot;YWJjMTIzIT8kKiYoKSctPUB+&quot;</code></td><td align="left">JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted.</td></tr><tr><td align="left">int32, fixed32, uint32</td><td align="left">number</td><td align="left"><code>1, -10, 0</code></td><td align="left">JSON value will be a decimal number. Either numbers or strings are accepted.</td></tr><tr><td align="left">int64, fixed64, uint64</td><td align="left">string</td><td align="left"><code>&quot;1&quot;, &quot;-10&quot;</code></td><td align="left">JSON value will be a decimal string. Either numbers or strings are accepted.</td></tr><tr><td align="left">float, double</td><td align="left">number</td><td align="left"><code>1.1, -10.0, 0, &quot;NaN&quot;, &quot;Infinity&quot;</code></td><td align="left">JSON value will be a number or one of the special string values “NaN”, “Infinity”, and “-Infinity”. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0.</td></tr><tr><td align="left">Any</td><td align="left"><code>object</code></td><td align="left"><code>&#123;&quot;@type&quot;: &quot;url&quot;, &quot;f&quot;: v, … &#125;</code></td><td align="left">If the Any contains a value that has a special JSON mapping, it will be converted as follows: <code>&#123;&quot;@type&quot;: xxx, &quot;value&quot;: yyy&#125;</code>. Otherwise, the value will be converted into a JSON object, and the <code>&quot;@type&quot;</code> field will be inserted to indicate the actual data type.</td></tr><tr><td align="left">Timestamp</td><td align="left">string</td><td align="left"><code>&quot;1972-01-01T10:00:20.021Z&quot;</code></td><td align="left">Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than “Z” are also accepted.</td></tr><tr><td align="left">Duration</td><td align="left">string</td><td align="left"><code>&quot;1.000340012s&quot;, &quot;1s&quot;</code></td><td align="left">Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix “s”. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix “s” is required.</td></tr><tr><td align="left">Struct</td><td align="left"><code>object</code></td><td align="left"><code>&#123; … &#125;</code></td><td align="left">Any JSON object. See <code>struct.proto</code>.</td></tr><tr><td align="left">Wrapper types</td><td align="left">various types</td><td align="left"><code>2, &quot;2&quot;, &quot;foo&quot;, true, &quot;true&quot;, null, 0, …</code></td><td align="left">Wrappers use the same representation in JSON as the wrapped primitive type, except that <code>null</code> is allowed and preserved during data conversion and transfer.</td></tr><tr><td align="left">FieldMask</td><td align="left">string</td><td align="left"><code>&quot;f.fooBar,h&quot;</code></td><td align="left">See <code>field_mask.proto</code>.</td></tr><tr><td align="left">ListValue</td><td align="left">array</td><td align="left"><code>[foo, bar, …]</code></td><td align="left"></td></tr><tr><td align="left">Value</td><td align="left">value</td><td align="left"></td><td align="left">Any JSON value. Check <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value">google.protobuf.Value</a> for details.</td></tr><tr><td align="left">NullValue</td><td align="left">null</td><td align="left"></td><td align="left">JSON null</td></tr><tr><td align="left">Empty</td><td align="left">object</td><td align="left"><code>&#123;&#125;</code></td><td align="left">An empty JSON object</td></tr></tbody></table><h3 id="JSON-options"><a href="#JSON-options" class="headerlink" title="JSON options"></a>JSON options</h3><ul><li><strong>Emit fields with default values</strong>:  proto3 解析为JSON 时不省略有默认值</li><li><strong>Ignore unknown fields</strong>:   proto3 解析为JSON 时忽略未知字段</li><li><strong>Use proto field name instead of lowerCamelCase name</strong>: 使用proto字段名代替lowerCamelCase. </li><li><strong>Emit enum values as integers instead of strings</strong>: 使用枚举值的数值代替枚举名称。</li></ul><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>常用选项 ：</p><ul><li>java_package (文件级选项):声明生成的 Java 类拥有的包名。 如果没有在.proto 文件中显示地声明 java_package 选项，默认采用 proto 的包名（在.proto 文件中用 package 关键字定义）作为生成的 Java 类的包名。 </li></ul><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.example.foo&quot;</span>;</code></pre><ul><li>java_outer_classname (文件级选项):编译生成的 Java 输出类的最外层类名（也是文件名）。 如果没有在.proto文件中定义 java_outer_classname 选项，默认将.proto 文件名转换为驼峰格式的文件名（例如 foo_bar.proto 编译生成 FooBar.java） 。</li></ul><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;Ponycopter&quot;</span>;</code></pre><ul><li>java_multiple_files(文件选项):如果为false，则只会为这个.proto文件生成一个. Java文件，以及所有的Java类/enum /等等。如果为true，将为每个Java类/枚举/等生成单独的. Java文件。这是一个布尔选项，默认为false。</li></ul><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> java_multiple_files = <span class="hljs-literal">true</span>;</code></pre><ul><li>optimize_for (文件级选项): <ul><li>SPEED — 默认值： protoc 编译器会根据你定义的消息类型生成序列化、解析和执行其它常规操作的代码。这些代码是高度优化了的。</li><li>CODE_SIZE:protoc 编译器会采用共享、反射技术来实现序列化、解析和其它操作的代码，以生成最小的类。 因此，所生成的代码比采用选项 SPEED 的要小得多，但是操作性能降低了。类的公共成员函数依然是一样的（用 SPEED 优化选项也是如此）。 这种模式是最有用的应用情况是：程序包含很多.proto 文件，但并不追求所有模块都有极快的速度。</li><li>LITE_RUNTIME:protoc 编译器生成的类，仅依赖”lite”运行时库 (libprotobuf-lite而不是 libprotobuf)。”lite”比完整库 小得多，但省略了某些功能，如描述符和反射。这对于运行在像手机这样的有空间限制的平台上的应用程序特别有用。 protoc 编译器仍将为所有方法生成最快速的代码，这和在 SPEED 模式一样。生成的类将为每一种语言实现 MessageLite版本的接口，只提供了完整的 Message 接口的一个子集的实现。</li></ul></li></ul><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> optimize_for = CODE_SIZE;</code></pre><ul><li><p>cc_enable_arenas(文件级选项): 为生成的 C++代码 启用 arena 内存管理功能。（译注：Arena Allocation，是一种 GC 优化技术，它可以有效地减少因内存碎片导致的 Full GC，从而提高系统的整体性能。）</p></li><li><p>objc_class_prefix(文件级选项):设置编译器从.proto 文件生成Objective-C的类和枚举类型的前缀 。没有默认值。Apple 的建议使用 3–5 个大写字母作为前缀。 请注意：所有的 2 个字母的前缀由苹果公司保留使用。</p></li><li><p>deprecated (字段选项): 这个选项如果设置为 true ，表示该字段已被废弃，你不应该在后续的代码中使用它。 在大多数语言中这没有任何实际的影响。在 Java 中，它会变@Deprecated 注释。</p></li></ul><pre><code class="hljs protobuf"><span class="hljs-built_in">int32</span> old_field = <span class="hljs-number">6</span> [deprecated=<span class="hljs-literal">true</span>];</code></pre><h2 id="Generating-Classes"><a href="#Generating-Classes" class="headerlink" title="Generating Classes"></a>Generating Classes</h2><pre><code class="hljs shell">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.protoprotoc --proto_path=src --java_out=build/gen src/foo.proto</code></pre><p>IMPORT_PATH 指在.proto 文件中解析 import 指令时的查找目录路径。如果省略，则使用当前目录。通过多次传递参数–proto_path，可以实现在多个导入目录中按顺序查找。缩写<code>-I=IMPORT_PATH </code></p><ul><li><p><code>--cpp_out</code> generates C++ code in <code>DST_DIR</code>. See the <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">C++ generated code reference</a> for more.</p></li><li><p><code>--java_out</code> generates Java code in <code>DST_DIR</code>. See the <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java generated code reference</a> for more.</p></li><li><p><code>--python_out</code> generates Python code in <code>DST_DIR</code>. See the <a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated">Python generated code reference</a> for more.</p></li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ol><li>Protocol Buffer 利用 varint 原理压缩数据以后，二进制数据非常紧凑，option 也算是压缩体积的一个举措。所以 Protocol Buffer体积更小，如果选用它作为网络数据传输，势必相同数据，消耗的网络流量更少。但是并没有压缩到极限，float、double 浮点型都没有压缩。</li><li>Protocol Buffer 比 JSON 和 XML 少了 {、}、: 这些符号，体积也减少一些。再加上 varint 压缩，gzip 压缩以后体积更小！</li><li>Protocol Buffer 是 Tag - Value (Tag - Length - Value)的编码方式的实现，减少了分隔符的使用，数据存储更加紧凑。</li><li>Protocol Buffer 另外一个核心价值在于提供了一套工具，一个编译工具，自动化生成 get/set 代码。简化了多语言交互的复杂度，使得编码解码工作有了生产力。</li><li>Protocol Buffer 不是自我描述的，离开了数据描述 <code>.proto</code> 文件，就无法理解二进制数据流。这点即是优点，使数据具有一定的“加密性”，也是缺点，数据可读性极差。所以 Protocol Buffer 非常适合内部服务之间 RPC 调用和传递数据。</li><li>Protocol Buffer 具有向后兼容的特性，更新数据结构以后，老版本依旧可以兼容，这也是 Protocol Buffer 诞生之初被寄予解决的问题。因为编译器对不识别的新增字段会跳过不处理。</li></ol>]]></content>
    
    
    <categories>
      
      <category>protobuf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac安装derby及Tomact JNDI引入数据源</title>
    <link href="/2021/03/03/mac-jndi-embed-tomcat-derby/"/>
    <url>/2021/03/03/mac-jndi-embed-tomcat-derby/</url>
    
    <content type="html"><![CDATA[<h3 id="安装derby"><a href="#安装derby" class="headerlink" title="安装derby"></a>安装derby</h3><ol><li><p>下载对应版本derby</p><p><a href="http://db.apache.org/derby/derby_downloads.html">http://db.apache.org/derby/derby_downloads.html</a></p></li><li><p>解压到指定目录</p><blockquote><p>/Library/Java/db-derby-10.13.1.1-bin</p></blockquote></li><li><p>配置环境变量</p><pre><code class="hljs sh">vim ~/.bash_profile</code></pre><pre><code class="hljs shell">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Homeexport DERBY_HOME=/Library/Java/db-derby-10.13.1.1-binexport PATH=$PATH:$JAVA_HOME/bin:$DERBY_HOME:.export CLASSPATH=$DERBY_HOME/lib/derby.jar:$DERBY_HOME/lib/derbyclient.jar:$DERBY_HOME/lib/derbytools.jar:.</code></pre><pre><code class="hljs shell">source  ~/.bash_profile</code></pre></li><li><p>查看derby信息</p><pre><code class="hljs shell">➜  ~ java org.apache.derby.tools.sysinfo------------------ Java 信息 ------------------Java 版本：        1.8.0_231Java 供应商：      Oracle CorporationJava 主目录：      /Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home/jreJava 类路径：      /Library/Java/db-derby-10.13.1.1-bin/lib/derby.jar:/Library/Java/db-derby-10.13.1.1-bin/lib/derbyclient.jar:/Library/Java/db-derby-10.13.1.1-bin/lib/derbytools.jar:.OS 名：            Mac OS XOS 体系结构：      x86_64OS 版本：          10.15.5Java 用户名：      zhengshuoJava 用户主目录：/Users/zhengshuoJava 用户目录：    /Users/zhengshuojava.specification.name: Java Platform API Specificationjava.specification.version: 1.8java.runtime.version: 1.8.0_231-b11--------- Derby 信息 --------[/Library/Java/db-derby-10.13.1.1-bin/lib/derby.jar] 10.13.1.1 - (1765088)[/Library/Java/db-derby-10.13.1.1-bin/lib/derbytools.jar] 10.13.1.1 - (1765088)[/Library/Java/db-derby-10.13.1.1-bin/lib/derbyclient.jar] 10.13.1.1 - (1765088)----------------------------------------------------------------------- 区域设置信息 -----------------当前区域设置：  [中文/中国 [zh_CN]]找到支持的区域设置：[cs] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[de_DE] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[es] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[fr] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[hu] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[it] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[ja_JP] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[ko_KR] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[pl] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[pt_BR] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[ru] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[zh_CN] 版本：10.13.1.1 - (1765088)找到支持的区域设置：[zh_TW] 版本：10.13.1.1 - (1765088)------------------------------------------------------------------------------------------------------------</code></pre></li><li><p>启动ij环境，输入 </p><pre><code class="hljs shell">➜  ~ java org.apache.derby.tools.ijij 版本 10.13<span class="hljs-meta">ij&gt;</span></code></pre></li><li><p>启动Derby数据库服务器</p><pre><code class="hljs shell">➜  ~ java -jar $DERBY_HOME/lib/derbyrun.jar server startWed Mar 03 15:06:49 CST 2021 : 已使用基本服务器安全策略安装了 Security Manager。Wed Mar 03 15:06:50 CST 2021 : Apache Derby 网络服务器 - 10.13.1.1 - (1765088) 已启动并准备接受端口 1527 上的连接</code></pre><p>Derby数据库和服务器配置成功。</p></li></ol><h3 id="Tomact-JNDI引入数据源"><a href="#Tomact-JNDI引入数据源" class="headerlink" title="Tomact JNDI引入数据源"></a>Tomact JNDI引入数据源</h3><ol><li><p><code>webapp/META-INF</code>下配置<code>context.xml</code></p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Context</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc/UserPlatformDB&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;javax.sql.DataSource&quot;</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">&quot;Container&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">description</span>=<span class="hljs-string">&quot;Derby database for User Platform&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">maxActive</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">maxIdle</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">maxWait</span>=<span class="hljs-string">&quot;10000&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;root&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;root&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">driverClassName</span>=<span class="hljs-string">&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;</span></span><span class="hljs-tag">              <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;jdbc:derby:/data/derby/db/user-platform;create=true&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span></code></pre></li><li><p><code>web.xml</code> 引入，与第一步内容要一致</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resource-ref</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>DB Connection<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">res-ref-name</span>&gt;</span>jdbc/UserPlatformDB<span class="hljs-tag">&lt;/<span class="hljs-name">res-ref-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">res-type</span>&gt;</span>javax.sql.DataSource<span class="hljs-tag">&lt;/<span class="hljs-name">res-type</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">res-auth</span>&gt;</span>Container<span class="hljs-tag">&lt;/<span class="hljs-name">res-auth</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resource-ref</span>&gt;</span></code></pre></li><li><p><code>pom.xml</code> 配置tomcat插件,<code>&lt;enableNaming&gt;true&lt;/enableNaming&gt;</code>一定要配置，否则jndi不起作用</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Tomcat Maven 插件用于构建可执行 war --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>tomcat-run<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                        <span class="hljs-comment">&lt;!-- 最终打包成可执行的jar包 --&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>exec-war-only<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                        <span class="hljs-comment">&lt;!-- ServletContext 路径 --&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">enableNaming</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enableNaming</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></li><li><p>java代码获取连接即可</p><pre><code class="hljs java">Context context = <span class="hljs-keyword">new</span> InitialContext();DataSource source = (DataSource)context.lookup(<span class="hljs-string">&quot;java:comp/env/jdbc/UserPlatformDB&quot;</span>);<span class="hljs-keyword">this</span>.connection = source.getConnection();</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>java lessons</category>
      
    </categories>
    
    
    <tags>
      
      <tag>derby</tag>
      
      <tag>jndi</tag>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo自定义标签路由调用链路</title>
    <link href="/2021/01/26/dubbo-tag-invoker-chain/"/>
    <url>/2021/01/26/dubbo-tag-invoker-chain/</url>
    
    <content type="html"><![CDATA[<h3 id="组件调用顺序-Dirctory，Router，LoadBalance、Filter"><a href="#组件调用顺序-Dirctory，Router，LoadBalance、Filter" class="headerlink" title="组件调用顺序 Dirctory，Router，LoadBalance、Filter"></a>组件调用顺序 <code>Dirctory</code>，<code>Router</code>，<code>LoadBalance</code>、<code>Filter</code></h3><pre><code class="hljs java">    组件              Directory              Router             LoadBalance      Filter    产物     Invocation -----&gt;  List&lt;Invoker&gt; -----&gt; List&lt;Invoker&gt; -----&gt; Invoker -----&gt; Result组件中的方法             list                 route                select         invoke</code></pre><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><img src="/images/dubbo-tag-invoker-chain/dubbo-tag-1662529.jpg" alt="dubbo-tag"></p><p><code>We do that on purpose, you need to do some extra work to make the tag passed along the invoke chain. For example, you add a filter working before ContextFilter and save tag before it get removed.</code></p><p><a href="https://github.com/apache/dubbo/issues/5638">https://github.com/apache/dubbo/issues/5638</a> </p><p>官方建议 也是通过filter设置</p>]]></content>
    
    
    <categories>
      
      <category>dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shardingsphere介绍</title>
    <link href="/2021/01/05/shardingsphere-introduce/"/>
    <url>/2021/01/05/shardingsphere-introduce/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://shardingsphere.apache.org/">ShardingSphere 官网</a></p><p>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款相互独立，却又能够混合部署配合使用的产品组成。 它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。</p><p>Apache ShardingSphere 定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 它通过关注不变，进而抓住事物本质。关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。</p><p>Apache ShardingSphere 5.x 版本开始致力于可插拔架构，项目的功能组件能够灵活的以可插拔的方式进行扩展。 目前，数据分片、读写分离、数据加密、影子库压测等功能，以及对 MySQL、PostgreSQL、SQLServer、Oracle 等 SQL 与协议的支持，均通过插件的方式织入项目。 开发者能够像使用积木一样定制属于自己的独特系统。Apache ShardingSphere 目前已提供数十个 SPI 作为系统的扩展点，而且仍在不断增加中。</p><p>ShardingSphere 已于2020年4月16日成为 <a href="https://apache.org/index.html#projects-list">Apache 软件基金会</a>的顶级项目。</p><h3 id="ShardingSphere-JDBC"><a href="#ShardingSphere-JDBC" class="headerlink" title="ShardingSphere-JDBC"></a>ShardingSphere-JDBC</h3><p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li></ul><p><img src="/images/shardingsphere-introduce/image-20201216153825102.png" alt="image-20201216153825102"></p><h3 id="ShardingSphere-Proxy"><a href="#ShardingSphere-Proxy" class="headerlink" title="ShardingSphere-Proxy"></a>ShardingSphere-Proxy</h3><p>定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供 MySQL 和 PostgreSQL 版本，它可以使用任何兼容 MySQL/PostgreSQL 协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat 等)操作数据，对 DBA 更加友好。</p><ul><li>向应用程序完全透明，可直接当做 MySQL/PostgreSQL 使用。</li><li>适用于任何兼容 MySQL/PostgreSQL 协议的的客户端。</li></ul><p><img src="/images/shardingsphere-introduce/shardingsphere-proxy-brief.png" alt="ShardingSphere-Proxy Architecture"></p><h3 id="ShardingSphere-Scaling"><a href="#ShardingSphere-Scaling" class="headerlink" title="ShardingSphere-Scaling"></a>ShardingSphere-Scaling</h3><p>ShardingSphere-Scaling 是一个提供给用户的通用的 ShardingSphere 数据接入迁移，及弹性伸缩的解决方案。</p><h3 id="ShardingSphere-UI"><a href="#ShardingSphere-UI" class="headerlink" title="ShardingSphere-UI"></a>ShardingSphere-UI</h3><p>ShardingSphere-UI 是 ShardingSphere 的一个简单而有用的web管理控制台。它用于帮助用户更简单的使用 ShardingSphere 的相关功能，目前提供注册中心管理、动态配置管理、数据库编排等功能。</p><p>项目结构上采取了前后端分离的方式，前端使用 Vue 框架，后端采用 Spring Boot 框架。使用标准的 Maven 方式进行打包，部署，同时也可以采用前后端分离的方式本地运行，方便开发调试。</p><h3 id="ShardingSphere-Sidecar（TODO）"><a href="#ShardingSphere-Sidecar（TODO）" class="headerlink" title="ShardingSphere-Sidecar（TODO）"></a>ShardingSphere-Sidecar（TODO）</h3><p>定位为 Kubernetes 的云原生数据库代理，以 Sidecar 的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即 <code>Database Mesh</code>，又可称数据库网格。</p><p>Database Mesh 的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互进行有效地梳理。 使用 Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><p><img src="/images/shardingsphere-introduce/shardingsphere-sidecar-brief.png" alt="ShardingSphere-Sidecar Architecture"></p><table><thead><tr><th align="left"></th><th align="left"><em>ShardingSphere-JDBC</em></th><th align="left"><em>ShardingSphere-Proxy</em></th><th align="left"><em>ShardingSphere-Sidecar</em></th></tr></thead><tbody><tr><td align="left">数据库</td><td align="left">任意</td><td align="left">MySQL/PostgreSQL</td><td align="left">MySQL/PostgreSQL</td></tr><tr><td align="left">连接消耗数</td><td align="left">高</td><td align="left">低</td><td align="left">高</td></tr><tr><td align="left">异构语言</td><td align="left">仅 Java</td><td align="left">任意</td><td align="left">任意</td></tr><tr><td align="left">性能</td><td align="left">损耗低</td><td align="left">损耗略高</td><td align="left">损耗低</td></tr><tr><td align="left">无中心化</td><td align="left">是</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">静态入口</td><td align="left">无</td><td align="left">有</td><td align="left">无</td></tr></tbody></table><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>ShardingSphere-JDBC采用无中心化架构，用于 Java 开发的高性能的轻量级应用。</p><p>ShardingSphere-Proxy 提供静态入口以及异构语言的支持，用于数据迁移及运维查询。</p><p>ShardingSphere-Scaling 用于数据迁移。</p><p><img src="/images/shardingsphere-introduce/image-20201216154030084.png" alt="image-20201216154030084"></p>]]></content>
    
    
    <categories>
      
      <category>shardingsphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shardingsphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shardingsphere之scaling</title>
    <link href="/2021/01/05/shardingsphere-scaling-introduce/"/>
    <url>/2021/01/05/shardingsphere-scaling-introduce/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ShardingSphere-Scaling 是一个提供给用户的通用的 ShardingSphere 数据接入迁移，及弹性伸缩的解决方案。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>目前的弹性伸缩解决方案为：临时地使用两个数据库集群，伸缩完成后切换的方式实现。</p><p><img src="/images/shardingsphere-scaling-introduce/scaling-principle-overview.cn.png" alt="伸缩总揽"></p><p>这种实现方式有以下优点：</p><ol><li>伸缩过程中，原始数据没有任何影响</li><li>伸缩失败无风险</li><li>不受分片策略限制</li></ol><p>同时也存在一定的缺点：</p><ol><li>在一定时间内存在冗余服务器</li><li>所有数据都需要移动</li></ol><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p><img src="/images/shardingsphere-scaling-introduce/image-20201216161515781.png" alt="image-20201216161515781"></p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>在准备阶段，弹性伸缩模块会进行数据源连通性及权限的校验，同时进行存量数据的统计、日志位点的记录，最后根据数据量和用户设置的并行度，对任务进行分片。</p><h3 id="存量数据迁移阶段"><a href="#存量数据迁移阶段" class="headerlink" title="存量数据迁移阶段"></a>存量数据迁移阶段</h3><p>执行在准备阶段拆分好的存量数据迁移作业，存量迁移阶段采用 JDBC 查询的方式，直接从数据节点中读取数据，并使用新规则写入到新集群中。</p><h3 id="增量数据同步阶段"><a href="#增量数据同步阶段" class="headerlink" title="增量数据同步阶段"></a>增量数据同步阶段</h3><p>由于存量数据迁移耗费的时间受到数据量和并行度等因素影响，此时需要对这段时间内业务新增的数据进行同步。 不同的数据库使用的技术细节不同，但总体上均为基于复制协议或 WAL 日志实现的变更数据捕获功能。</p><ul><li>MySQL：订阅并解析 binlog</li><li>PostgreSQL：采用官方逻辑复制 <a href="https://www.postgresql.org/docs/9.4/test-decoding.html">test_decoding</a></li></ul><p>这些捕获的增量数据，同样会由弹性伸缩模块根据新规则写入到新数据节点中。当增量数据基本同步完成时（由于业务系统未停止，增量数据是不断的），则进入规则切换阶段。</p><h3 id="规则切换阶段"><a href="#规则切换阶段" class="headerlink" title="规则切换阶段"></a>规则切换阶段</h3><p>在此阶段，可能存在一定时间的业务只读窗口期，通过业务停止写入或设置数据库只读或ShardingSphere的熔断机制，让旧数据节点中的数据短暂静态，确保增量同步已完全完成。</p><p>这个窗口期时间短则数秒，长则数分钟，取决于数据量和用户是否需要对数据进行强校验。 确认完成后，Apache ShardingSphere 可通过配置中心修改配置，将业务导向新规则的集群，弹性伸缩完成。</p><p>我们由于有写业务无法无法完全停止写入，目前只能尽可能减少写入，然后开启双写，并且停止迁移，进行数据校验，对有问题数据进行补处理。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="ScalingTask"><a href="#ScalingTask" class="headerlink" title="ScalingTask"></a>ScalingTask</h3><p>任务最小执行单元</p><p>主要实现类：</p><ul><li>InventoryDataScalingTask（History）存量</li><li>IncrementalDataScalingTask（RealTime） 增量</li></ul><h3 id="Dumper（Reader）"><a href="#Dumper（Reader）" class="headerlink" title="Dumper（Reader）"></a>Dumper（Reader）</h3><p>从原库获取数据，核心操作主要有：</p><ul><li>setChannel(Channel channel); 设置Channel</li><li>dump(); 从原库获取数据，并保存数据到channel中</li></ul><p>主要实现类：</p><ul><li>JDBCDumper</li><li>LogDumper</li></ul><h3 id="Importer（Writer）"><a href="#Importer（Writer）" class="headerlink" title="Importer（Writer）"></a>Importer（Writer）</h3><p>把数据写入数据到新库,核心操作主要有：</p><ul><li>setChannel(Channel channel); 设置Channel</li><li>write(); 写入数据到数据库</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Channel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushRecord</span><span class="hljs-params">(Record dataRecord)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <span class="hljs-function">List&lt;Record&gt; <span class="hljs-title">fetchRecords</span><span class="hljs-params">(<span class="hljs-keyword">int</span> batchSize, <span class="hljs-keyword">int</span> timeout)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ack</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>主要实现类：</p><ul><li>MemoryChannel</li><li>DistributionChannel</li></ul><h3 id="存量迁移"><a href="#存量迁移" class="headerlink" title="存量迁移"></a>存量迁移</h3><p><img src="/images/shardingsphere-scaling-introduce/image-20201216175534892.png" alt="image-20201216175534892"></p><ol><li><p>获取minId、maxId，并根据id和concurrency 把迁移id区间平均分配到各个Task（InventoryDataScalingTask）。</p><p>minId=1，maxId=100，concurrency=10，则</p><p>task1 id区间为 1-10，task2 id区间为 11-20 ……</p></li><li><p>每个Task都有一个dumper 从原库批量获取DataRecord，并push到MemoryChannel，BlockingQueue长度为10000，超过则阻塞等待</p></li><li><p>Importer从MemoryChannel批量获取DataRecord并依次插入到新库中，然后ack()。</p></li><li><p>当dumper获取不到数据时，则push一个FinishedRecord到MemoryChannel，dumper结束。</p></li><li><p>Importer获取到FinishedRecord时，Importer结束，Task执行完毕。</p></li></ol><h3 id="增量迁移"><a href="#增量迁移" class="headerlink" title="增量迁移"></a>增量迁移</h3><p><img src="/images/shardingsphere-scaling-introduce/image-20201216175621918.png" alt="image-20201216175621918"></p><ol><li><p>每次Task（InventoryDataScalingTask）执行完成，callBack 检测是否所有Task（InventoryDataScalingTask）执行完成。都执行完成开启增量迁移Task（IncrementalDataScalingTask）。</p></li><li><p>增量只有一个dumper 从迁移开始时记录的binlog位置subscribe数据，并根据hashcode和channelNumber取模push到Memorychannel。</p><p>String index = Integer.toString(Math.abs(dataRecord.hashCode()) % channelNumber);</p></li><li><p>Importer从MemoryChannel批量获取DataRecord并依次插入/更新到新库中，然后ack()。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>shardingsphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shardingsphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty-start</title>
    <link href="/2020/12/18/netty-start/"/>
    <url>/2020/12/18/netty-start/</url>
    
    <content type="html"><![CDATA[<p>Netty 是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器</p><p>和客户端。</p><p><img src="/images/netty-start/image-20201218173515498.png" alt="image-20201218173515498"></p><p>FTP</p><p>SMTP</p><p>HTTP</p><p>WebSocket</p>]]></content>
    
    
    <categories>
      
      <category>netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shardingsphere之mysql数据迁移优化</title>
    <link href="/2020/12/04/shardingsphere-sacling-mysql-speed-increase/"/>
    <url>/2020/12/04/shardingsphere-sacling-mysql-speed-increase/</url>
    
    <content type="html"><![CDATA[<p>水平分库项目，用了ShardingSphere-scaling做数据迁移，由于存量数据迁移过程中过于缓慢，对数据迁移模块进行优化。</p><p>迁移效率提升600%，校验效率提升6000%。</p><table><thead><tr><th>表名</th><th>数据</th><th>迁移耗时</th><th>校验耗时</th></tr></thead><tbody><tr><td>screen_case</td><td>16000w</td><td>12h（优化前）</td><td></td></tr><tr><td>dc_rule_random</td><td>7000w</td><td>1h</td><td>8h（优化前）</td></tr><tr><td>ap_apply</td><td>14000w</td><td>2h</td><td>14m</td></tr><tr><td>ap_apply_ext</td><td>17000w</td><td>4h2m</td><td>18m</td></tr></tbody></table><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p><code>rewriteBatchedStatements=true</code></p><p>改写存量数据为批量插入，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> (Connection connection = dataSource.getConnection()) &#123;    connection.setAutoCommit(<span class="hljs-keyword">false</span>);    <span class="hljs-keyword">try</span> (PreparedStatement ps = connection.prepareStatement(insertSql)) &#123;        ps.setQueryTimeout(<span class="hljs-number">60</span>);        <span class="hljs-keyword">for</span> (DataRecord record : list) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; record.getColumnCount(); i++) &#123;                ps.setObject(i + <span class="hljs-number">1</span>, record.getColumn(i).getValue());            &#125;            ps.addBatch();        &#125;        ps.executeBatch();    &#125;    connection.commit();&#125;</code></pre><p>当时以为这样写就可以了，但是迁移速度还是很慢只比原来单条插入快了一倍左右，经过研究发现，这并不是真正的批量插入，只是多条插入一次事务，降低了事务开销。</p><pre><code class="hljs mysql">INSERT IGNORE INTO &#96;user&#96;(&#96;id&#96;,&#96;cust_no&#96;,&#96;age&#96;,&#96;name&#96;,&#96;delete_at&#96;) VALUES(59985,&#39;UR59985&#39;,98,&#39;name:1605538600723&#39;,0) ;INSERT IGNORE INTO &#96;user&#96;(&#96;id&#96;,&#96;cust_no&#96;,&#96;age&#96;,&#96;name&#96;,&#96;delete_at&#96;) VALUES(59986,&#39;UR59986&#39;,23,&#39;name:160512312311&#39;,0) ;</code></pre><p>在 MySQL JDBC 中，批操作的提交默认是逐条进行的。而在链接中加入以下参数，会把多条语句合并成一条提交。当 SQL 语句累积到一定数量（由数据库可接受的最大数据包大小决定），再一次性提交到数据库，减少了与数据库的交互次数，大大提高了效率。<code>rewriteBatchedStatements=true</code></p><pre><code class="hljs mysql">INSERT IGNORE INTO &#96;user&#96;(&#96;id&#96;,&#96;cust_no&#96;,&#96;age&#96;,&#96;name&#96;,&#96;delete_at&#96;) VALUES(50200,&#39;UR50200&#39;,98,&#39;name:1606138884516&#39;,0),(50202,&#39;UR50202&#39;,98,&#39;name:1606138884516&#39;,0),(50204,&#39;UR50204&#39;,98,&#39;name:1606138884516&#39;,0);</code></pre><p>分析源码可以发现：<br>当mysql版本&gt;4.1.1，并且rewriteBatchedStatements=true，批操作语句总数大于 4 条时（nbrCommands &gt; 4），才会合并成一条语句提交。</p><pre><code class="hljs java">com.mysql.jdbc.StatementImpl#executeBatchInternal  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span>[] executeBatchInternal() <span class="hljs-keyword">throws</span> SQLException &#123;...nbrCommands = (<span class="hljs-keyword">long</span>[])<span class="hljs-keyword">this</span>.batchedArgs.size();<span class="hljs-comment">// 获取批操作语句数量</span>    <span class="hljs-keyword">this</span>.batchedGeneratedKeys = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">this</span>.batchedArgs.size());    <span class="hljs-keyword">boolean</span> multiQueriesEnabled = locallyScopedConn.getAllowMultiQueries();<span class="hljs-comment">// 当前连接是否允许一次查询多条语句，默认为 false</span>    Object sqlEx;<span class="hljs-keyword">if</span> (locallyScopedConn.versionMeetsMinimum(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &amp;&amp; (multiQueriesEnabled || locallyScopedConn.getRewriteBatchedStatements() &amp;&amp; nbrCommands &gt; <span class="hljs-number">4</span>)) &#123;sqlEx = <span class="hljs-keyword">this</span>.executeBatchUsingMultiQueries(multiQueriesEnabled, (<span class="hljs-keyword">int</span>)nbrCommands, individualStatementTimeout);    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>[])sqlEx;    &#125;    ...&#125;</code></pre><h2 id="预编译设置"><a href="#预编译设置" class="headerlink" title="预编译设置"></a>预编译设置</h2><p> jdbc客户端参数：</p><p>  cachePrepStmts：默认false.是否缓存prepareStatement对象。每个连接都有一个缓存，是以sql为唯一标识的LRU cache. 同一连接下，不同stmt可以不用重新创建prepareStatement对象。</p><p>  prepStmtCacheSize：LRU cache中prepareStatement对象的个数。一般设置为最常用sql的个数。</p><p>  prepStmtCacheSqlLimit：prepareStatement对象的大小。超出大小不缓存。</p><h2 id="服务端编译"><a href="#服务端编译" class="headerlink" title="服务端编译"></a>服务端编译</h2><p>useServerPrepStmts=false 关闭服务器端编译，sql语句在客户端编译好再发送给服务器端。</p><p>如果为true,sql会采用占位符方式发送到服务器端，在服务器端再组装sql语句。</p><p>占位符方式：<code>INSERT INTO t (c1,c2) VALUES (？,？),(？,？),(？,？);</code></p><p>此方式就会产生一个问题，当列数*提交记录数&gt;65535</p><p>时就会报错：Prepared statement contains too many placeholders,</p><p>这是由于我把“提交记录数量”设为10000，而要插入记录的表字段有30个，所以要进行批量插入时需要30*10000=300000  &gt; 65535 ，故而报错。</p><p><strong>解决方案</strong></p><p><strong>方案1：</strong>把DB连接中的 rewriteBatchedStatements 给设置为false（或者去掉），不过这个操作会影响数据的插入速度。</p><p><strong>方案2：</strong>更改表输出的设计。确保30个输出字段的和提交记录数量的乘积不超过65535。比如把提交记录数量由10000更改为450（30*2000=60000&lt; 65535）</p><p>当然我们的目的是为了提高数据库写速度，并且不考虑sql注入问题，所以当<code>rewriteBatchedStatements =true</code>时<code>useServerPrepStmts=false</code>配合使用较为合适。</p><h2 id="压缩数据传输"><a href="#压缩数据传输" class="headerlink" title="压缩数据传输"></a>压缩数据传输</h2><p><code>useCompression=true</code>压缩数据传输，优化客户端和MySQL服务器之间的通信性能。</p><pre><code class="hljs java">com.mysql.jdbc.MysqlIO#doHandshake<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doHandshake</span><span class="hljs-params">(String user, String password, String database)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123; ···          <span class="hljs-comment">//</span>    <span class="hljs-comment">// Can&#x27;t enable compression until after handshake 在握手后</span>    才能启用压缩    <span class="hljs-comment">//</span>    <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">this</span>.serverCapabilities &amp; CLIENT_COMPRESS) != <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-keyword">this</span>.connection.getUseCompression() &amp;&amp; !(<span class="hljs-keyword">this</span>.mysqlInput <span class="hljs-keyword">instanceof</span> CompressedInputStream)) &#123;        <span class="hljs-comment">// The following matches with ZLIB&#x27;s compress()</span>        <span class="hljs-keyword">this</span>.deflater = <span class="hljs-keyword">new</span> Deflater();        <span class="hljs-keyword">this</span>.useCompression = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">this</span>.mysqlInput = <span class="hljs-keyword">new</span> CompressedInputStream(<span class="hljs-keyword">this</span>.connection, <span class="hljs-keyword">this</span>.mysqlInput);    &#125;···&#125;</code></pre><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_compress">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_compress</a></p><p><img src="/images/shardingsphere-sacling-mysql-speed-increase/image-20201124001333217.png" alt="image-20201124001333217"></p><p>压缩协议提升网络传输性能，对于一些网络环境较差的用户会有很大的帮助，但是会相应地增加CPU开销，适用于传输数据量很大带宽不高的情况，这是一个CPU和网络资源的平衡问题。</p><p>经过测试 直连数据库会速度提高 5% 左右，效果不明显。通过shardingsphere-proxy连接数据库速度也并无明显提升</p><p>因此目前带宽无瓶颈的情况下，未使用压缩协议</p><p>直连数据库批量插入5分钟：</p><table><thead><tr><th>useCompression</th><th>100条avg</th><th>1000条avg</th><th>10000条avg</th></tr></thead><tbody><tr><td>true</td><td>11ms</td><td>42ms</td><td>307ms</td></tr><tr><td>false</td><td>12ms</td><td>43ms</td><td>321ms</td></tr></tbody></table><p>通过shardingsphere-proxy连接数据库批量插入5分钟：</p><table><thead><tr><th>useCompression</th><th>100条avg</th><th>1000条avg</th><th>10000条avg</th></tr></thead><tbody><tr><td>true</td><td>31ms</td><td>101ms</td><td>725ms</td></tr><tr><td>false</td><td>32ms</td><td>100ms</td><td>732ms</td></tr></tbody></table><p><strong>适用场景</strong></p><p>MySQL 压缩协议适合的场景是 MySQL 的服务器端和客户端之间传输的数据量很大，或者可用带宽不高的情况，典型的场景有如下两个：</p><p>a、查询大量的数据，带宽不够（比如导出数据的时候）；</p><p>b、复制的时候 binlog 量太大，启用 slave_compressed_protocol 参数进行日志压缩复制。</p><h3 id="压缩协议简介"><a href="#压缩协议简介" class="headerlink" title="压缩协议简介"></a>压缩协议简介</h3><p>压缩协议是 MySQL 通信协议的一部分，要启用压缩协议进行数据传输，需要 MySQL 服务器端和客户端都支持 zlib 算法。启动压缩协议会导致 CPU 负载略微上升。使用启用压缩协议使用-C 参数或者 –compress=true 参数启动客户端的压缩功能。如果启用了-C 或者 compress=true 选项，那么在连接到服务器段的时候，会发送 0x0020（CLIENT_COMPRESS）的服务器权能标志位，和服务器端协商通过后（3 次握手以后），就支持压缩协议了。由于采用压缩，数据包的格式会发生变化，具体的变化如下：</p><p>未压缩的数据包格式：</p><p><img src="/images/shardingsphere-sacling-mysql-speed-increase/1497240545250_627_1497240545431.png" alt="img"></p><p>压缩后的数据包格式：</p><p><img src="/images/shardingsphere-sacling-mysql-speed-increase/1497240560529_3423_1497240560716.png" alt="img"></p><p>大家可能留意到压缩后的数据报格式有压缩和未压缩之分，这个是 MySQL 为了较少 CPU 开销而做的一个优化。如果内容小于 50 个字节的时候，就不对内容进行压缩，而大于 50 字节的时候，才会启用压缩功能。具体的规则如下：</p><p>当第三个字段的值等于 0x00 的时候，表示当前包没有压缩，因此 n<code>*</code>byte 的内容为 1<code>*</code>byte,n<code>*</code>byte，即请求类型和请求内容。</p><p>当第三个字段的值大于 0x00 的时候，表示当前包已采用 zlib 压缩，因此使用的时候需要对 n<code>*</code>byte 进行解压，解压后内容为 1<code>*</code>byte,n<code>*</code>byte，即请求类型和请求内容。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>原库读取数据设置</strong></p><p><code>useServerPrepStmts=true</code><br><code>cachePrepStmts=true</code></p><p><strong>新库插入数据设置</strong></p><p><code>rewriteBatchedStatements=true </code><br><code>useServerPrepStmts=false </code><br><code>useCompression=false</code></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://my.oschina.net/u/4418437/blog/3648369">https://my.oschina.net/u/4418437/blog/3648369</a><br><a href="https://cloud.tencent.com/developer/article/1005252">https://cloud.tencent.com/developer/article/1005252</a><br><a href="https://www.cnblogs.com/lispking/p/3604063.html">https://www.cnblogs.com/lispking/p/3604063.html</a><br><a href="https://stackoverflow.com/questions/2506460/when-should-i-use-mysql-compressed-protocol">https://stackoverflow.com/questions/2506460/when-should-i-use-mysql-compressed-protocol</a><br><a href="https://blog.csdn.net/qq_43153418/article/details/104002252">https://blog.csdn.net/qq_43153418/article/details/104002252</a><br><a href="https://www.cnblogs.com/justfortaste/p/3920140.html">https://www.cnblogs.com/justfortaste/p/3920140.html</a></p>]]></content>
    
    
    <categories>
      
      <category>shardingsphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shardingsphere</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/10/01/hello-world/"/>
    <url>/2020/10/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>hello world</category>
      
    </categories>
    
    
    <tags>
      
      <tag>router</tag>
      
      <tag>hello world</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
